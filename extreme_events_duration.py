"""
===============================================
   Extreme Events - Daily Event Occurrence Computation
===============================================

This script computes daily extreme event occurrence masks from 
duration data generated by the extreme-event computation pipeline.

Workflow:
    1. Load duration data (≥5 consecutive extreme days)
    2. Apply land mask at specified depth
    3. Compute daily event occurrence mask (assign 1 to all event days)
    4. Save results and process with CDO for temporal sums

    
Input: 
    duration.nc - NetCDF file with extreme event durations
Output:
    days_total.nc    - Daily binary mask (0=no event, 1=event day)
    days_yearly.nc   - Yearly sum of event days (via CDO yearsum)
    days_monthly.nc  - Monthly sum of event days (via CDO monsum)


Event types supported:
    - MHW (Marine Heatwaves) - variable: to
    - LOX/DEO (Low Oxygen extremes) - variable: o2  
    - OAX (Ocean Acidification extremes) - variable: hi (H+)

Dependencies:
    - xarray, numpy, matplotlib, pandas, numba
    - CDO (command-line tool) for temporal aggregation
    - Land mask file: ___________/land_mask_3d.nc

Usage:
    python extreme_events_duration.py <variable> <depth>
    Example: python extreme_events_duration.py to 8

Author:
    Cristina Radin (2025)
    cristina.radin@uni-hamburg.de
    AI4PEX (https://ai4pex.org/)
    University of Hamburg

    
Key difference from duration.nc:
- duration.nc contains only the total event duration at the LAST 
    time step of each event (e.g., value = 10 at day 10 of a 10-day event)
- days_total.nc assigns 1 to EVERY day during an extreme event
    (e.g., values = 1 at days 1 through 10 for a 10-day event)

Notes:
    - Duration data must have time, depth, lat, lon dimensions
    - Land mask is required for proper ocean-only processing
    - CDO must be available in system PATH for temporal aggregation
    - Uses parallel Numba computation for performance

================================================
"""



"""
===============================================
 Extreme Events - Daily Event Occurrence Computation
===============================================
"""

import xarray as xr
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os 
import subprocess 
from numba import jit, prange
import sys 


LAND_MASK_3D_PATH = '___________/land_mask_3d.nc'


@jit(nopython=True, parallel=True)
def extreme_days_numba(duration_var, land_mask):

    """
    Convert event durations to daily binary mask.
    
    For each grid point, when duration[t] > 0 (last day of event),
    marks all days in [t-duration+1, t] as 1.
    """
    n_time, _, n_lat, n_lon = duration_var.shape
    resultado = np.zeros((n_time, n_lat, n_lon), dtype=np.float32)  
    
    for lat in prange(n_lat):
        for lon in range(n_lon):
            if np.isnan(land_mask[lat, lon]):
                continue
            
            for t in range(n_time):
                duration = duration_var[t, 0, lat, lon]
                if duration > 0:
                    dur_int = int(duration)
                    start = max(0, t - dur_int + 1)
                    for i in range(start, t + 1):
                        resultado[i, lat, lon] = 1.0
    
    return resultado

def load_global_land_mask():
    # Load 3D global land mask from NetCDF file.
    try:
        return xr.open_dataarray(LAND_MASK_3D_PATH)
    except:
        mask_ds = xr.open_dataset(LAND_MASK_3D_PATH)
        return mask_ds['land_mask']

def get_land_mask_for_depth(land_mask_3d, depth_value):
    # Extract 2D land mask for specific depth.
    try:
        if isinstance(depth_value, str):
            depth_value = float(depth_value)
        
        mask_2d = land_mask_3d.sel(depth=depth_value, method='nearest')
        
        print(f"  Mask: {mask_2d.depth.values}m "
              f"(requested: {depth_value}m)")
        
        return mask_2d
    except Exception as e:
        print(f"  Error obtaining mask: {e}")
        return xr.ones_like(land_mask_3d.isel(depth=0))



def main():
    # Read command-line arguments
    if len(sys.argv) >= 3:
        var_from_bash = sys.argv[1]  # "to", "o2", "hi"
        depth_arg = sys.argv[2]      # "8", "51", "186.5"
    else:
        var_from_bash = "to"
        depth_arg = "8"
    
    # Format depth for file paths
    try:
        depth_value = float(depth_arg)
    except:
        depth_value = 8.0
    
    depth_for_path = depth_arg
    if depth_for_path.endswith('.0'):
        depth_for_path = depth_for_path[:-2]
    
    # Event type configuration
    variables = [
        {"name": "to", "name2":"to", "event_type": "mhw",  "event_name": "MHW", "label": "Temperature (ºC)"}, 
        {"name": "o2", "name2":"o2",  "event_type": "deo",  "event_name": "LOX", "label": "Oxygen (μmol O2 m-3)"},  
        {"name": "hi", "name2":"hi",  "event_type": "oax", "event_name": "OAX", "label": "[H+] (μmol m-3)"}  
    ]
    
    # Find variable configuration
    idx_var = None
    for var_dict in variables:
        if var_dict["name"] == var_from_bash:
            idx_var = var_dict
            break
    
    if idx_var is None:
        raise ValueError(f"Not valid '{var_from_bash}'. Use : to, o2, hi")
    
    var = idx_var["name2"]
    var_path = idx_var["name"]
    extreme = idx_var["event_type"]
    extreme_label = idx_var["event_name"]
    extreme_label_full = idx_var["label"]
    

    # Build paths
    path = f'___________/extremes_out_final/{extreme}_{var_path}/depth{depth_for_path}/tmp/'
    path_out = f'___________/extremes_out_final/{extreme}_{var_path}/depth{depth_for_path}/'
    
    os.makedirs(path_out, exist_ok=True)
    
    print("="*70)
    print(f"Extreme event and variable selected: {extreme_label} ({var})")
    print(f"Depth: {depth_arg}m")
    print("="*70)
    

    print("\n1. LOADING LAND MASK...")
    land_mask_3d = load_global_land_mask()
    land_mask_2d = get_land_mask_for_depth(land_mask_3d, depth_value)
    

    print("\n2. LOADING DATA...")
    
    # Duration data
    ds_duration = xr.open_dataset(path + 'duration.nc')
    duration_var = ds_duration[var]
    

    print("\n3. CALCULATING EVENT DAYS...")
    duration_var_np = duration_var.values
    land_mask_np = land_mask_2d.values
    
    # Ensure correct array dimensions
    if land_mask_np.ndim == 2:
        pass
    elif land_mask_np.ndim == 1:
        land_mask_np = land_mask_np[np.newaxis, :]
    else:
        land_mask_np = land_mask_np.squeeze()
    
    resultado = extreme_days_numba(duration_var_np, land_mask_np)
    
    print(f"   Event days calculated: {np.sum(resultado == 1.0):,}")
    
    
    print("\n4. SAVING RESULTS...")
    
    da_result = xr.DataArray(
        resultado,
        dims=('time', 'lat', 'lon'),
        coords={
            'time': ds_duration.time,
            'lat': ds_duration.lat,
            'lon': ds_duration.lon
        },
        name='days_total',
        attrs={
            'long_name': 'Extreme event day mask',
            'units': '1',
            'description': '1 = day with extreme event (≥5 consecutive days)',
            'variable_original': var,
            'event_type': extreme,
            'depth': f'{depth_arg}m'
        }
    )
    
    ds_out = xr.Dataset({'days_total': da_result})
    
    if hasattr(ds_duration, 'attrs'):
        ds_out.attrs.update(ds_duration.attrs)
    
    ds_out.attrs.update({
        'title': 'Extreme Event Day Mask',
        'source': 'Generated from duration.nc',
        'history': f'Created by process_events.py on {pd.Timestamp.now()}',
        'author': 'Cristina Radin'
    })
    
    output_path = path + 'days_total.nc'
    
    encoding = {
        'days_total': {
            'dtype': 'float32',
            'zlib': True,
            'complevel': 1,
            '_FillValue': -9999.0
        },
        'time': {
            'dtype': 'double',
            'units': ds_duration.time.attrs.get('units', 'days since 1985-01-01'),
            'calendar': ds_duration.time.attrs.get('calendar', 'proleptic_gregorian')
        },
        'lat': {'dtype': 'float32'},
        'lon': {'dtype': 'float32'}
    }
    
    ds_out.to_netcdf(output_path, encoding=encoding)
    print(f"Saved: {output_path}")
    

    # CDO processing

    print("\n5. PROCESSING WITH CDO...")
    
    days_yearly_path = path + 'days_yearly.nc'
    days_monthly_path = path + 'days_monthly.nc'
    
    # Yearly sum
    cmd_yearly = ['cdo', '-b', 'F32', 'yearsum', output_path, days_yearly_path]
    result_y = subprocess.run(cmd_yearly, capture_output=True, text=True)

    
    # Monthly sum
    cmd_monthly = ['cdo', '-b', 'F32', 'monsum', output_path, days_monthly_path]
    result_m = subprocess.run(cmd_monthly, capture_output=True, text=True)

    
 
    print("\n" + "="*70)
    print("PROCESSING COMPLETED")
    print("="*70)

    
if __name__ == "__main__":
    main()
